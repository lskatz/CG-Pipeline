#!/usr/bin/env perl

# run-prediction: Perform standard prediction protocol operations on input FASTA file(s)
# Author: Andrey Kislyuk (kislyuk@gatech.edu)

# TODO: investigate integration of Genomix, Jigsaw, etc.

package PipelineRunner;
my ($VERSION) = ('$Id: $' =~ /,v\s+(\d+\S+)/o);

my $settings = {
	appname => 'cgpipeline',
};
my $stats;

use strict;
use FindBin;
use lib "$FindBin::RealBin/../lib";
$ENV{PATH} = "$FindBin::RealBin:".$ENV{PATH};
use AKUtils qw(logmsg);

use Getopt::Long;
use File::Temp ('tempdir');
use File::Path;
use File::Spec;
use File::Copy;
use File::Basename;
use List::Util qw(min max sum shuffle);
use Bio::Seq;
use Bio::SeqIO;
#use Bio::SeqFeature::Gene::GeneStructure;
use Bio::SeqFeature::Generic;
use Bio::Species;
use Bio::Annotation::SimpleValue;
use AKUtils;
use CGPipeline::TagFactory;

$0 = fileparse($0);
local $SIG{'__DIE__'} = sub { my $e = $_[0]; $e =~ s/(at [^\s]+? line \d+\.$)/\nStopped $1/; die("$0: ".(caller(1))[3].": ".$e); };
sub logmsg {my $FH = $PipelineRunner::LOG || *STDOUT; print $FH "$0: ".(caller(1))[3].": @_\n";}

exit(main());

sub main() {
	$settings = AKUtils::loadConfig($settings);

	my $usage = "$0 input.mfa [, input2.mfa, ...] -strain_name=name [-tag_prefix=prefix] [-classification=classification] [-R references.mfa] [-C workdir] [-blast_db=db] [-o=output_filename.gb]";

	die("Usage: $usage\n") if @ARGV < 1;

	my @cmd_options = ('ChangeDir=s', 'Reference=s@', 'keep', 'blast_db=s', 'outfile=s', 'strain_name=s', 'tag_prefix=s', 'classification=s');
	GetOptions($settings, @cmd_options) or die;
	die("Argument strain_name is required. Usage: $usage\n") unless defined $$settings{strain_name};
	die("Argument classification is required. Usage: $usage\n") unless defined $$settings{classification};
	
	$$settings{outfile} ||= "$0.out.gb";

	my @l = split(/\s+/, $$settings{classification});
	$$settings{classification} = [@l[$#l-5..$#l]]; # last 6 words
	unshift(@{$$settings{classification}}, join(" ", @l[0..$#l-6])); # all but last 6 words (species name - 1 or more words)

	my @ref_files = @{$$settings{Reference}} if defined $$settings{Reference};

	my @input_files = @ARGV;

	foreach my $file (@input_files, @ref_files) {
		$file = File::Spec->rel2abs($file);
		die("Input or reference file $file not found") unless -f $file;
	}

	$$settings{tempdir} = tempdir($$settings{tempdir} or File::Spec->tmpdir()."/$0.$$.XXXXX", CLEANUP => !($$settings{keep}));
	logmsg "Temporary directory is $$settings{tempdir}";

	my ($input_seqs, $ref_seqs) = loadInputs(\@input_files, \@ref_files);
	my $predictions = getGenePredictions(\@input_files, \@ref_files, $input_seqs, $ref_seqs, $settings);
	my $gb_filename = generateGenBankFile($input_seqs, $predictions, $settings);
	logmsg "Output is in $gb_filename";
}

sub loadInputs($$) {
	my ($input_files, $ref_files) = @_;
	my ($input_seqs, $ref_seqs) = ({}, {});
	foreach my $file (@$input_files) {
		$input_seqs = {%$input_seqs, %{AKUtils::readMfa($file)}};
	}
	foreach my $file (@$ref_files) {
		$ref_seqs = {%$ref_seqs, %{AKUtils::readMfa($file)}};
	}
	return ($input_seqs, $ref_seqs);
}

sub getGenePredictions($$$$$) {
	my ($input_files, $ref_files, $input_seqs, $ref_seqs, $settings) = @_;

	$$settings{prediction_blast_db} = $$settings{blast_db} if defined $$settings{blast_db};
	if ($$settings{Reference}) {
		AKUtils::printSeqsToFile($ref_seqs, "$$settings{tempdir}/ref_seqs.mfa");
		$$settings{local_blast_db} = AKUtils::formatBLASTdb("$$settings{tempdir}/ref_seqs.mfa");
	}
	
	# FIXME
	die("multiple input files not supported") if @$input_files > 1;

	my (%all_predictions, %unified_predictions);
	my @minority_rep_orfs;

# FIXME: workaround for gibbs sampler bug - turn off RBS motif finding in GeneMark
$$settings{gm_trainer_xopts} .= " --motif=0";

	# Obtain ab initio predictions
	my $genemark_predictions;
	if ($$settings{prediction_use_genemark}) {
		$genemark_predictions = AKUtils::getGenemarkPredictions($input_seqs, $settings);
	}
	my $glimmer_predictions = AKUtils::getGlimmer3Predictions($input_seqs, $settings);
	my $blast_predictions = {};
	my $blast_predictions = AKUtils::getBLASTGenePredictions($input_seqs, $settings);

	# Combine and index predictions by strand, stop
	foreach my $pred_set ($genemark_predictions, $glimmer_predictions, $blast_predictions) {
		next unless $pred_set;
		foreach my $seq (keys %$pred_set) {
			foreach my $pred (@{$$pred_set{$seq}}) {
				push(@{$all_predictions{$seq}->{$$pred{strand}}->{$$pred{stop}}}, $pred);
			}
		}
	}
	
	if ($$settings{prediction_use_genemark}) {
		$$settings{min_predictors_to_call_orf} ||= 2;
	} else {
		$$settings{min_predictors_to_call_orf} ||= 1;
	}

	# Categorize and reconcile predictions
	foreach my $seq (sort AKUtils::alnum keys %all_predictions) {
		foreach my $strand (keys %{$all_predictions{$seq}}) {
			foreach my $stop (keys %{$all_predictions{$seq}->{$strand}}) {
				my $contrib_predictions = $all_predictions{$seq}->{$strand}->{$stop};
				if (scalar(@$contrib_predictions) < $$settings{min_predictors_to_call_orf}) {
					push(@minority_rep_orfs, @$contrib_predictions); next;
				}
				my %starts;

				foreach my $pred (@$contrib_predictions) {
					$starts{$$pred{predictor}} = $$pred{start};
				}
				my $best_start;
				if ($contrib_predictions->[0]->{strand} eq '+') {
					# Choose the least trivial (most downstream) predicted start.
					$best_start = max($starts{gmhmmp}, $starts{Glimmer3});

					if (defined $starts{BLAST} and $starts{BLAST} < $best_start) {
						my $snapped_start = AKUtils::snapToStart($starts{BLAST}, $$input_seqs{$seq}, undef, $stop, '+');
						# BLAST alignment extends upstream of the predicted start, so find the closest Met to the start predicted by BLAST.
						# warn "BLAST alignment upstream of predicted start (+): snapped to position $snapped_start\n";
						$best_start = $snapped_start if defined $snapped_start
							and defined $starts{gmhmmp} and $starts{gmhmmp} != $starts{Glimmer3};
					}
				} else {
					$starts{gmhmmp} ||= 1e999; $starts{Glimmer3} ||= 1e999;
					$best_start = min($starts{gmhmmp}, $starts{Glimmer3});
#					die("Internal error") if $best_start == 1e999;
					if (defined $starts{BLAST} and $starts{BLAST} > $best_start) {
						my $snapped_start = AKUtils::snapToStart($starts{BLAST}, $$input_seqs{$seq}, $stop, undef, '-');
						# BLAST alignment extends upstream of the predicted start, so find the closest Met to the start predicted by BLAST.
						# warn "BLAST alignment upstream of predicted start (-): snapped to position $snapped_start\n";
						$best_start = $snapped_start if defined $snapped_start
							and defined $starts{gmhmmp} and $starts{gmhmmp} != $starts{Glimmer3};
					}
#					$best_start = length($$input_seqs{$seq}) if $best_start > length($$input_seqs{$seq}) - 3; # FIXME: signal truncated predicts

				}
				my %prediction;
				foreach my $contrib_pred (@$contrib_predictions) {
					$prediction{$_} = $$contrib_pred{$_} for keys %$contrib_pred;
				}
				$prediction{start} = $best_start;
				($prediction{strand} eq '+' ? $prediction{lo} : $prediction{hi}) = $best_start;
				$prediction{predictor} = [];
				push(@{$prediction{predictor}}, $$_{predictor}) for @$contrib_predictions;
				
				$unified_predictions{$seq}->{$strand}->{$stop} = \%prediction;

				my $nt_seq = substr($$input_seqs{$seq}, min($best_start, $stop)-1, abs($best_start - $stop)+1);
				if ($contrib_predictions->[0]->{strand} eq '-') {
					$nt_seq = reverse($nt_seq); $nt_seq =~ tr/ATGC/TACG/;
				}
				my $aa_seq = AKUtils::dna2aa($nt_seq);

#				print "$best_start..$stop\t"; print " $$_{predictor}" for @{$all_predictions{$seq}->{$strand}->{$stop}};
#				print " [ @s ] [ L=".length($$input_seqs{$seq})." ]\n";
#				warn("WARNING: L(pred)>2000") if abs($best_start-$stop)>2800;
#				warn("WARNING: L(pred)<100") if abs($best_start-$stop)<100;

				# NB: longest known protein in e. coli is 1538 aa
				if (length($aa_seq) < 30 or length($aa_seq) > 2000 or $aa_seq !~ /M.+\*$/) {
					warn("WARNING: abnormal translated sequence: \n\t$nt_seq\n\t$aa_seq\n");
				}

			}
		}
	}

	if ($$settings{prediction_print_minority_reports}) {
		open(MR, '>', "$$settings{outfile}.minority_reports.log")
			or die("Unable to open file $$settings{outfile}.minority_reports.log for writing: $!");
		# print MR "Minority reports:\n";
		print MR "$$_{seqname}:$$_{start}..$$_{stop} ($$_{strand}) [L=".abs($$_{start}-$$_{stop})."] [P=$$_{predictor}]\n"
			for sort {$$a{seqname} cmp $$b{seqname}} @minority_rep_orfs;
		close MR;
	}

	my $trna_predictions = AKUtils::gettRNAscanSEPredictions($input_seqs, $settings);
	foreach my $seqname (keys %$trna_predictions) {
		foreach my $pred (@{$$trna_predictions{$seqname}}) {
			$$pred{predictor} = ['tRNAscanSE'];
			$unified_predictions{$seqname}->{$$pred{strand}}->{$$pred{stop}} = $pred;
		}
	}

	return \%unified_predictions;
}

sub generateGenBankFile($$$) {
	my ($seqs, $predictions, $settings) = @_;
	die("Internal error: no strain name supplied") unless defined $$settings{strain_name};
	die("Internal error: no classification supplied") unless defined $$settings{classification};
	die("Internal error: no output filename supplied") unless defined $$settings{outfile};

	$$settings{division} ||= 'BCT';

	my $gb_out_h = Bio::SeqIO->new(-file => '>'.$$settings{outfile}, -format => 'genbank');
	my $species_obj = Bio::Species->new(-classification => $$settings{classification},
		-sub_species => $$settings{strain_name},
	);

	$$settings{tag_prefix} ||= $$settings{strain_name}."_";
	if (grep('_', split('',$$settings{tag_prefix}))>1){
		warn "Tag prefix \"$$settings{tag_prefix}\" is not compliant with NCBI policy\n";
	}

	my $cds_tag_factory = CGPipeline::TagFactory->new({factory_type => "draft_orf_tagger",
		strain_name => $$settings{strain_name},
		tag_prefix => $$settings{tag_prefix}});
	my $trna_tag_factory = CGPipeline::TagFactory->new({factory_type => "draft_orf_tagger",
		strain_name => $$settings{strain_name},
		tag_prefix => $$settings{tag_prefix}.'t'});
	my $rrna_tag_factory = CGPipeline::TagFactory->new({factory_type => "draft_orf_tagger",
		strain_name => $$settings{strain_name},
		tag_prefix => $$settings{tag_prefix}.'r'});

	foreach my $seqname (sort keys %$seqs) {
		my $gb_seqname = $seqname; $gb_seqname =~ s/\s+/_/g;
		my $gbseq = Bio::Seq::RichSeq->new(-seq => $$seqs{$seqname},
			-id  => $gb_seqname,
			-desc => " $$settings{strain_name}, unfinished sequence, whole genome shotgun sequence",
			-keywords => ['WGS'],
			-species => $species_obj,
			-division => $$settings{division},
		);
		my @preds_for_seq;
		foreach my $strand (keys %{$$predictions{$seqname}}) {
			push(@preds_for_seq, values(%{$$predictions{$seqname}->{$strand}}));
		}

		foreach my $pred (sort {$$a{stop} <=> $$b{stop}} @preds_for_seq) {
			my $nt_seq = substr($$seqs{$seqname}, min($$pred{start}, $$pred{stop})-1, abs($$pred{start} - $$pred{stop})+1);
			if ($$pred{strand} eq '-') {
				$nt_seq = reverse($nt_seq); $nt_seq =~ tr/ATGC/TACG/;
			}

			my $pred_gene_feature = new Bio::SeqFeature::Generic(-primary_tag => 'gene',
				-start => $$pred{start},
				-end => $$pred{stop},
				-strand => ($$pred{strand} eq '+' ? 1 : -1),
#				-gene => ,
			);
			my $pred_feature = new Bio::SeqFeature::Generic(-primary_tag => $$pred{type},
				-start => $$pred{start},
				-end => $$pred{stop},
				-strand => ($$pred{strand} eq '+' ? 1 : -1),
#				-gene => ,
			);

			if ($$pred{type} eq 'CDS') {
				my $locus_tag = $cds_tag_factory->nextTag();
				$pred_gene_feature->add_tag_value('locus_tag', $locus_tag);
				$pred_feature->add_tag_value('locus_tag', $locus_tag);
				my $aa_seq = AKUtils::dna2aa($nt_seq);
				$pred_feature->add_tag_value('transl_table', $$settings{prediction_transl_table});
				$pred_feature->add_tag_value('translation', substr($aa_seq, 0, length($aa_seq)-1));
				$pred_feature->add_tag_value('evidence', 'predicted');
				$pred_feature->add_tag_value('note', 'Predictors: '.join(', ', @{$$pred{predictor}}));
			} elsif ($$pred{type} eq 'tRNA') {
				my $locus_tag = $trna_tag_factory->nextTag();
				$pred_gene_feature->add_tag_value('locus_tag', $locus_tag);
				$pred_feature->add_tag_value('locus_tag', $locus_tag);
				$pred_feature->add_tag_value('evidence', 'predicted');
				$pred_feature->add_tag_value('note', 'Predictors: '.join(', ', @{$$pred{predictor}}));
				$pred_feature->add_tag_value('product', 'tRNA-'.$$pred{trna_type});
				$pred_feature->add_tag_value('note', 'codon recognized: '.$$pred{trna_codon_recognized});
			} elsif ($$pred{type} eq 'rRNA') {
				my $locus_tag = $rrna_tag_factory->nextTag();
				$pred_gene_feature->add_tag_value('locus_tag', $locus_tag);
				$pred_feature->add_tag_value('locus_tag', $locus_tag);
#				$pred_feature->add_tag_value('product', '23S ribosomal RNA');
				# TODO: Finish me
			} else { die "Internal error" }

			$gbseq->add_SeqFeature($pred_gene_feature);
			$gbseq->add_SeqFeature($pred_feature);
		}
		$gb_out_h->write_seq($gbseq);
	}
	
	return $$settings{outfile};
}
